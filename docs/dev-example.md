
# Technical Overview

## Specification

### transaction.proto 

`transaction.proto`

```protobufs
message FrontierTransaction {

  string value = 1;     // hex encoded big integer
  string input = 2;     // hex bytes
  int64 nonce = 3;      //
  string gasPrice = 4;  // hex encoded big integer
  int64 gasLimit = 5;

  optional string v = 6;    // hex encoded big integer
  optional string r = 7;    // hex encoded big integer
  optional string s = 8;    // hex encoded big integer

  optional string to = 9;  //
  optional string chain_id = 10;   // hex encoded big integer
  optional string sender = 11;
}

message AccessListEntry {
  string address = 1;
  repeated string storageKeys = 2;
}

message EIP2930Transaction {

  string chain_id = 1;  // hex encoded big integer
  string value = 2;     // hex encoded big integer
  string input = 3;     // hex bytes
  int64 nonce = 4;      //
  string gasPrice = 5;  // hex encoded big integer
  int64 gasLimit = 6;

  repeated AccessListEntry accessList = 7;

  optional int32 v = 8;     // byte value
  optional string r = 9;    // hex encoded big integer
  optional string s = 10;    // hex encoded big integer

  optional string to = 11;
  optional string sender = 12;
}

message EIP1559Transaction {

  string chain_id = 1;  // hex encoded big integer
  string value = 2;     // hex encoded big integer
  string input = 3;     // hex bytes
  int64 nonce = 4;      //
  string maxPriorityFeePerGas = 5;  // hex encoded big integer
  string maxFeePerGas = 6;          // hex encoded big integer
  int64 gasLimit = 7;

  repeated AccessListEntry accessList = 8;

  optional int32 v = 9;       // byte value
  optional string r = 10;    // hex encoded big integer
  optional string s = 11;    // hex encoded big integer

  optional string to = 12;
  optional string sender = 13;
}

enum TransactionType {
  FRONTIER = 0;
  EIP2930 = 1;
  EIP1559 = 2;
}

message Transaction {

  TransactionType type = 1;
  optional string signed = 2;
  optional int64 deadline_at = 3;

  optional string transaction_hash = 16;
  optional int32 transaction_index = 17;

  optional string block_hash = 18;
  optional string block_number = 19;
  
  optional string gas_price = 20;

  optional TransactionReceipt receipt = 21;

  oneof payload {
    FrontierTransaction transaction_frontier = 22;
    EIP2930Transaction transaction_eip2930 = 23;
    EIP1559Transaction transaction_eip1559 = 24;
  }

  oneof action {
    org.openmev.protobuf.action.SwapExactTokensForTokens swap_exact_tokens_for_tokens = 33;
    org.openmev.protobuf.action.SwapTokensForExactTokens swap_tokens_for_exact_tokens = 34;
    org.openmev.protobuf.action.SwapExactETHForTokens swap_exact_eth_for_tokens = 35;
    org.openmev.protobuf.action.SwapTokensForExactETH swap_tokens_for_exact_ETH = 36;
    org.openmev.protobuf.action.SwapExactTokensForETH swap_exact_tokens_for_ETH = 37;
    org.openmev.protobuf.action.SwapETHForExactTokens swap_eth_for_exact_tokens = 38;
    org.openmev.protobuf.action.SwapExactTokensForTokensSupportingFeeOnTransferTokens swap_exact_tokens_for_tokens_supporting_fee_on_transfer_tokens = 39;
    org.openmev.protobuf.action.SwapExactETHForTokensSupportingFeeOnTransferTokens swap_exact_eth_for_tokens_supporting_fee_on_transfer_tokens = 40;
    org.openmev.protobuf.action.SwapExactTokensForETHSupportingFeeOnTransferTokens swap_exact_tokens_for_eth_supporting_fee_on_transfer_tokens = 41;
  }
}
```

The arbitrage profit generated by second order is sent to the `msg.sender` of
the first order.

The first order will still lose 5%(assumption) in slippage.

Arbitrage profits will rarely be more than the slippage loss.

If someone front runs the transaction sent by the Cabal:

1. They pay for the gas while post confirmation of transaction the fees for
   order1 goes to the relayer in the signed order.
2. They lose 5% in slippage as our real user does.

## Transaction Engine

The OpenMEV Engine uses a batch auction-based matching engine to execute orders.
Batch auctions were chosen to reduce the impact of frontrunning on the exchange.

1. All orders for the given market are collected.

2. Orders beyond their time-in-force are canceled.

3. Orders are placed into separate lists by market side, and aggregate supply
   and demand curves are calculated.

4. The matching engine discovers the price at which the aggregate supply and
   demand curves cross, which yields the clearing price. If there is a
   horizontal cross - i.e., two prices for which aggregate supply and demand are
   equal - then the clearing price is the midpoint between the two prices.

5. If both sides of the market have equal volume, then all orders are completely
   filled. If one side has more volume than the other, then the side with higher
   volume is rationed pro-rata based on how much its volume exceeds the other
   side. For example, if aggregate demand is 100 and aggregate supply is 90,
   then every order on the demand side of the market will be matched by 90%.

Orders are sorted based on their price, and order ID. Order IDs are generated at
post time and is the only part of the matching engine that is time-dependent.
However, the oldest order IDs are matched first so there is no incentive to post
an order ahead of someone elseâ€™s.


## Endpoints v1

### `POST `

```
/v1/quote
```

A user can get a quote based on the current market conditions and potentially
the other transactions that are queued. The only reason for this to be on the
backend is if we find value in quoting based on the other transactions in the
queue. Details of this quote calculation formula need to be researched.

### `POST`

```
/v1/transact
```

A user submits their transaction call after signing it. This is an asynchronous
request that will insert the swap transaction in a queue. The call returns a
TransactionId. The user can then listen for the result of their transaction via
the websocket feed which will report all completed and failed transactions.

## Sequencing

On any additions to the queue, the server runs a sequencing algorithm to
optimize MEV, then decides if it is time to submit the transactions to a miner
for the current block.

Garbage collection will have to be run on the queues periodically to remove
transactions that are not going to be successful due to timeout or slippage.

On successful and failed (garbage collected) transactions, the backend will send
WebSocket messages to the frontend to notify users.

## Gwei Service

The Gwei Service is an important part of the overall system. Since Gwei pricing
is the most important portion of the overall system efficacy it is decoupled
from the application itself and run in a separate stack entirely. We inject the
Gwei pricing service by loading at runtime via `startGasWorker()`. _note_ we use
the term GasWorker to draw a distinction between `gwei` and `gas`. Whereas
`gwei` is understood as a specific SI unit, gas is more abstract.

## Gas Pricing Service

**Note**: EIP1559 Gas Pricing Compatible

For accurate pricing, we trim off the lowest price with the fastest time and
highest price with the slowest times until 80% of the data is represented; these
are _outliers_.

See the API Service here: [https://api.txprice.com](https://api.txprice.com)

```js
/**
*
* @summary filters transactions from blocks
* @note transaction wait duration and gas price taken into consideration
*/
blocks.forEach((block) => {
       block.transactions.forEach((tx) => {
           const price = parseFloat(ethers.utils.formatUnits(tx.gasPrice, "gwei"));
           const duration = tx.waitDuration;
 /**
 *
 *  @summary Purge anything that takes over 5 minutes
 *  @param duration
 *  @type {seconds}
 *  @exports TransactionTimeDuration
 */
   if (duration > (60 * 60)) { return; }

   if (duration < (1 * 60)) {
               data.fast.push(price);
       } else if (duration < (5 * 60)) {
               data.medium.push(price);
       } else {
               data.slow.push(price);
       }
```

### Transaction Details

```js
/**
 * Add the transaction details
 *  @const diff
 *  @param waitDuration
 *  @param dataLength
 *  @param gasLimit
 *  @param value
 */
const diff = timestamp - seenTime;
txs.push({
  w: diff, // waitDuration, not a delta but difference
  d: ethers.utils.hexDataLength(tx.data), // dataLength
  l: tx.gasLimit.toString(), // gasLimit
  p: ethers.utils.formatUnits(tx.gasPrice, 'gwei'), // gasPrice
  v: ethers.utils.formatUnits(tx.value), // value
});
```

### Canary Scanning

> Failsafe guard

```js
// Canary scanning (check every second)
// If we go too long without a ne block or a new transaction, it indicates the
// underlying connection to a backend has probably disconnected.
setInterval(() => {
  const delta = getTime() - canaryTimer;
  if (delta > MAX_DISCONNECT) {
    console.log(`Canary: forcing restart...`);
    process.exit();
  }
}, 1000).unref();
```

> How to subscribe to gas price changes

```ts
import { Container } from 'typedi';
import EventConstants from '@constants/events';
import EventEmitter from 'events';

const { GAS_CHANGE } = EventConstants;

const events: EventEmitter = Container.get('eventEmitter');
events.on(GAS_CHANGE, (newGasPrice) => {});
```
